import Image from 'next/image'
import { notFound } from 'next/navigation'

import { getMeal } from '@/lib/meals'
import classes from './page.module.css'

// for dynamic pages, you can add metadata by, not exporting a constant or variable named metadata
// but by instead exporting an async function called generateMetadata, because NextJS is also looking for 
// functions like this.
// It is checking whether there is such a function, & if there is such a function 
// NextJS will execute it for you to return such a metadata object in that function
// How does this help us with dynamic data?
// This function receives the same data our page component receives as props. So below 
// we also get an object with a params key, & that of course allows us to get the meal for which the metadata 
// should be generated by simply accessing mealSlug & passing that to getMeal.
export async function generateMetadata({ params }) {
  const meal = getMeal(params.mealsSlug)
  // We can then return a title that is set equal to meal title & a description that is set to meal.summary
  // Eg that is how we can generate the metadata for a dynamic page
  // On the webpage URL, if we now visit a meal, we can see it's title, it's name represented here in the tab title.
  // If we enter some invalid slug here, we now get an error though instead of the not found page, because the metadata 
  // is actually generated first & the below now simply fails. When I try to access the title on the meal, that fails 
  // because meal is undefined. Therefore we should actually add this if check meal, not found to ensure that we show the 
  // notFound page if generating the metadata fails, which it does if we do not find that meal.
  // 
  if(!meal) {
    notFound()
  }
  
  return {
    title: meal.title,
    description: meal.summary
  }
}

// This page will become active whenever the user enters the - localhost:3000/meals/something
// which is not shared though, because NextJS is smart enough to understand that there is a more
// specifically named folder, which therefore has precedence over this dynamic segment. Anything but the share dirctory,
// - localhost:3000/meals/share, like "abc"- localhost:3000/meals/abc, will be treated as a value for this dynamic segment
// & will lead to the activation of this page.js file
// With help of props we are receiving on this page. NextJS is passing some special props to these special files
// or to these components in those special files - Eg every component that is stored in a page.js file will receive a special params prop,
// which you can therefore, destructure
export default function MealDetailsPage({params}) {
    // getMeal needs that slug & that slug is the part that is encoded in the URL, that is caught with the help of this 
    // placeholder [mealSlug] folder, this placeholder
    // How do we then get access to that concrete value that is part of the URL? 
    // This params prop will then itself contain an object as a value where any dynamic path segment that is configured for this route 
    // will be stored as a key-value pair. [mealSlug] folder - will be used as the key & the actual value encoded in the URL will be used
    // as a value for that key & the actual value encoded in the URL will be used as a value for that key.
    // We need to look for that value in the database. We can pass params.mealsSlug to getMeal, & that will be that identifier, that allows us to fetch a meal
    // from the database. We did not get anything, the reason for that is that getMeal actually returns a promise because
    // we are using the async keyword in meals.js 
    const meal = getMeal(params.mealsSlug)
    // Output a meal image that belongs to a meal
    // fill prop, you will not know the exact dimensions of the image file yet, & therefore, you will 
    // use this fill prop as a fallback or solution
    // <a href={`mailto:${'EMAIL'}`}</a> - this link allows us to send an email to that creator. That
    // will open the mail program, so that users can send an email to that person
    // the actual href value will be a dynamically generated string
    // <p className={classes.instructions}></p> - those should actually be output as HTML code,
    // which can be achieved in React by targeting the dangerouslySetInnerHTML prop on an element
    // dangerouslySetInnerHTML={{__html: '...',}} - it is called like this because you open yourself up to cross-site scripting
    // attacks when outputting content as HTML content, at least if you are not validating it. The prop then wants an
    // object as a value, & that object should have an __html property, which then contains the actual HTML code that
    // should be output on the screen
    // <Image src={meal.image} fill />, we have an image key in the database
    // meal.creator_email - because this is the name we are using in the database
    // meal.instructions is not formatted perfectly & the reason for that is that the line breaks we get in these instructions are ignored
    // We can fix this by overriding meal.instructions. Hence replacing parts of that string
    // meal.instructions.replace(/\n/) - We can use our regular expression to look for all line breaks which are identified by this 
    // special character 
    // /\n/g - the g, look for all of them in this string & by then replacing them with the br tag
    // If the meal is undefined, if we did not find a meal
    if(!meal) {
        // We then show the closest not-found page available in this project
        // This can be triggered by calling a special function that is provided by NextJS, the notFound function
        // which is imported from next/navigation
        // Calling this function will stop the component from executing & will show the closest not-found or error page.
        notFound()
    }
    
    
    meal.instructions = meal.instructions.replace(/\n/g, '<br />')
    return (
      <>
      <header className={classes.header}>
        <div className={classes.image}>
          <Image src={meal.image} alt={meal.title} fill />
        </div>
        <div className={classes.headerText}>
          <h1>{meal.title}</h1>
          <p className={classes.creator}>
            by <a href={`mailto:${meal.creator_email}`}>{meal.creator}</a>
          </p>
          <p className={classes.summary}>{meal.summary}</p>
        </div>
      </header>
      <main>
        <p
          className={classes.instructions}
          dangerouslySetInnerHTML={{
            __html: meal.instructions,
          }}
        ></p>
      </main>
    </>
  );
}
  