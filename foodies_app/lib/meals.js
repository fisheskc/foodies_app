// the file system API (fs). This allows us to work with the file system
import fs from 'node:fs'

import sql from "better-sqlite3";
import slugify from "slugify";
import xss from "xss";

// We establish the database connection by executing SQL as a function
// & then passing the name of the database - sql('meals.db'), as a string to that function. 
const db = sql('meals.db');
// This async function will return a promise. The code in the function does not normally produce one,
// but now it will be wrapped into a promise, that is what async does.
// We added the delay in this function where we fetch the meals from the database. We added a two second pause before the page updates.
// If you then go to another page & you come back, the meals page is there instantly, we do not have to wait those five seconds then.
// That is the case because NextJS performs some pretty aggressive caching (production mode) under the hood.
// It caches any page you visited, including the data of that page, & if you then go to another page & come back, it loads that existing page
// from the cache, so that it can show it to you quickly as possible. Only if you reload this page, if you leave the page, & you come back, essentially,
// only then is the page recreated.

export async function getMeals() { 
// We use the DB object & then prepare a new statement, a new SQL statement that should be executed.
// We run this method here, but with the all method. Run would be used if you were inserting data.
// If you were looking for a single row you could use get instead. For multiply rows it is all. 
// Server component functions can actually be converted to async functions.
// This adds an arbitary delay, and the actions takes a bit longer
// You would not normally add the below code to slow things down, which adds the extra delay.
    await new Promise((resolve) => setTimeout(resolve, 5000)); 
    // throw new error('Loading meals failed');  
    return db.prepare('SELECT * FROM meals').all()
}
// We then expect to get the slug of the meal that identifies the meal that should be fetched
// return db.prepare('SELECT * FROM meals WHERE slug = ' +slug) - "+slug" that would be insecure
// That opens yourself up to an SQL injection. Instead, you should use a question mark as a placeholder
// & then call the get method since you only want a single record, & then you pass the value that should
// be inserted for that placeholder to get
// Under the hood, this better-sqlite3 package we are using will then protect you against SQL injection attacks
// That is why you should add dynamic values into your statements. This should then return a meal
// async has been removed from function getMeal which will no longer return a promise. 
export function getMeal(slug) {
    return db.prepare('SELECT * FROM meals WHERE slug = ?').get(slug) 
}
// We expect a meal object as an input 
// eg - We need to generate a slug, because in the database, we store a slug for every "meal" & we do not get that from the form.
// Instead, we want to generate it based on the title
// This is a slugify function, it prevents cross-site scripting attacks
// This saveMeal function that will store both a file & the data in the database. 
export async function saveMeal(meal) {
    // In addition, to pass a configuration object to slug. {lower: true} - this forces all characters to be lowercase.
    // Instead of using these extra constants or variables, we can of course add a slug property to "meal"
    // on the fly - const slug to meal.slug
    meal.slug = slugify(meal.title, {lower: true})
    // We want to remove any harmful content from those instructions & for that we can use npm xss which is imported
    // which turns out to be a function to call it on meal.instructions. This is so that we sanitize & clean those instructions
    meal.instructions = xss(meal.instructions)
    // We get the extension of the uploaded image, because it could be a JPG, PNG file. We dig into the meal image
    // We call split to split it on the dot & pop the last element, which will be the file extension
    // We get from the form the image object that is automatically generated by the browser, & that object will have a name property which carries the name
    // of the image file that was uploaded.
    const extension = meal.image.name.split(".").pop();
    // we generate a unique file name & not use the file name of the user
    // We create a file name that uses .slug here - meal.slug = slugify(meal.title, {lower: true})
    // the extension - ${extension}
    // To make sure that you do not accidently override other images with the same file name, you could consider adding some random
    // unique element to each filname
    // We need to write this to a file in the public folder with the help of an API provided by node JS.
    const fileName = `${meal.slug}.${extension}`;
    // We can use this fs module call createWriteStream which will create a stream that allows us to write
    // data to a certain file. createWriteStream then needs a path to default, & it will then return a stream object
    // which you can then use to write to that path. We create a dynamic string here, the folder public/image/ and then the filename
    // to which you want to write, must be included in the path. We can inject that fileName. We then get a stream which we can store
    // in which we can use to write to that path
    // const stream = fs.createWriteStream(`public/images/${fileName}`)
    const stream = fs.createWriteStream(`public/images/${fileName}`);
    // We can write to the stream. This write method then wants a chunk - What is the chunk, it means that we should convert the image,
    // to a so-called buffer, to a bufferedimage.
    // We use the image object which we get from the form - formData, function shareMeal, in the actions.js file
    // That object has an arrayBuffer method which will give you a buffer, which we need for the write method.
    // arrayBuffer will give you a promise that eventually resolves to that buffer & therefore we must await this
    const bufferedImage = await meal.image.arrayBuffer();
    // Write actually wants a regular buffer. So therefore we have to call to buffer from & pass this arrayBuffer
    // We are writing this buffer to this path, including this file `public/images/${fileName}`
    // This write method now also takes a second argument. The first argument is the thing you want to write.
    // The second argument is a function that will be executed
    // We get an error argument which is null if everything worked, but which will hold some error information, if something went wrong. 
    // We have written the image to this file  
  stream.write(Buffer.from(bufferedImage), (error) => {
        // We should check if error is truthy
        if(error) {
            throw new Error ('saving image failed!')
        }
    })
    // We need to store the overall data in the database. We start by overridiing the image that is stored in the meal object
    // with a path to the image where we stored it. We do not want to store the image file itself in the database, databases are
    // not built for that, we just want to store the path. Hence we override the image object in the meal with that path here. 
    // You should remove the public segment (public), because all requests for images will be sent to the public folder automatically.
    // Or the content of the public folder will be served as if it were served on the root level of your Server
    // Therefore, the public segment should not be included here & it will not be included later when requests for that image will be sent 
    meal.image = `/images/${fileName}`;

    // We can now save it in the database. We can use the db object.
    // We insert some data into the meals table, all fields that were configured when we created the table except for the id, because that will 
    // be populated automatically
    // We must specify the values that should be inserted into those fields. You could directly inject those values, but this is not recommended,
    // because that approach would be vulnerable to SQL injection attacks
    // Instead, you should use those placeholders, one for every field though. You can also use another syntax, supported by better-sqlite, which was used in the initdb.js file
    // null, @slug, @title, @image, @summary etc. You can target specific fields by their name
    // We then pass an object to the run function, which we will call on this prepared statement & better-sqlite.
    // The package we are using to execute this command will then look at those property names in that object you are passing to it to extract the values stored under those 
    // property names & it will then use those values to store them in those fields
    // However, you must make sure that the order you get in VALUES, is the same as the INSERT INTO & therefore I will reorder that 
    // We can then call run on that statement & pass our meal object to it.
    // Thanks to this syntax we are using in VALUES, the data for those fields will automatically be extracted. 
    db.prepare(`
        INSERT INTO meals
                (title, summary, instructions, creator, creator_email, image, slug)
        VALUES (
            @title,
            @summary,
            @instructions,
            @creator,
            @creator_email,
            @image,
            @slug
            )
       `).run(meal);
    }